<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Apr 24 12:31:14 2018 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>get_telem.pro (Documentation for /Users/penton/Dropbox/LASP/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="get_telem.pro (Documentation for /Users/penton/Dropbox/LASP/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">;  NAME: get_telem.pro</span>
<span class="comments">;</span>
<span class="comments">;  PURPOSE: Read the ascii telemetry files and return as an IDL structure.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    out=get_telem(TIMES, [,time_in_sec=time_in_sec] [,Edge_Trim=Edge_Trim]</span>
<span class="comments">;            [,VERBOSE=verbose] [,DEBUG=DEBUG] [,DO_PLOT=do_plot],$</span>
<span class="comments">;            [,ADD_DOPPCORR=add_doppcorr][ADD_DISTCORR=add_distcorr])</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS:</span>
<span class="comments">;   TIMES        : A two element array that gives the [START,END] times of the SCAN.</span>
<span class="comments">;                  The times are in milli-seconds unless the TIME_IN_SEC keyword is set.</span>
<span class="comments">;   TIMES_IN_SEC :  Set if the TIMES vector is in seconds instead of milli-seconds.</span>
<span class="comments">;   EDGE_TRIM    : Set to the number of bins at the beginning and end of the scan to</span>
<span class="comments">;                  ignore in the output structure. Default is 2 bins.</span>
<span class="comments">;   SORT_BYGRATPOS : Set to sort the return structure in increasing gratpos (default=0)</span>
<span class="comments">;   SORT_BYWAVELENGTH : Set to sort the return structure in increasing wavelength (default=0)</span>
<span class="comments">;                      Performed after sort_bygratpos.</span>
<span class="comments">;   VERBOSE      :  Set if reporting of details is desired</span>
<span class="comments">;   DEBUG        :  Set to report additional information useful in debugging.</span>
<span class="comments">;	ADD_DARKCORR :  Set to include BACKGROUND CORRECTION (based on temperature)</span>
<span class="comments">;	ADD_DOPPCORR :  Set to include DOPPLER CORRECTION</span>
<span class="comments">;	ADD_DISTCORR :  Set to include DISTANCE CORRECTION</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT PARAMETERS:</span>
<span class="comments">;     Structure of data products.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;		DownScan=[9.434134508500002E14, 9.434178736700002E14]</span>
<span class="comments">;		DS_telem=get_telem(DownScan,/add_darkcorr,/add_distcor,/add_doppcorr)</span>
<span class="comments">;		help,DS_telem,/str</span>
<span class="comments">;</span>
<span class="comments">;   START_TIME      FLOAT       9.43413e+14</span>
<span class="comments">;   END_TIME        FLOAT       9.43418e+14</span>
<span class="comments">;   TIMES_MS        DOUBLE    Array[2354]</span>
<span class="comments">;   TIMES_S         DOUBLE    Array[2354]</span>
<span class="comments">;   TIME_MS0        DOUBLE       9.4341346e+14</span>
<span class="comments">;   TIME_S0         DOUBLE       9.4341346e+11</span>
<span class="comments">;   TEMPS           DOUBLE    Array[2354]</span>
<span class="comments">;   GGRATPOS        FLOAT     Array[2354]</span>
<span class="comments">;   GWAVES          DOUBLE    Array[2354]</span>
<span class="comments">;   GCOUNTS         FLOAT     Array[2354]</span>
<span class="comments">;   IRR             DOUBLE    Array[2354]</span>
<span class="comments">;   WAVES           DOUBLE    Array[2354]</span>
<span class="comments">;   COUNTS          DOUBLE    Array[2354]</span>
<span class="comments">;   DELTA_WAVES     DOUBLE    Array[2354]</span>
<span class="comments">;   BINSIZE         DOUBLE        0.0063524922</span>
<span class="comments">;   DOPPCORR        INT              1</span>
<span class="comments">;   DWAVES          DOUBLE    Array[2354]</span>
<span class="comments">;   DW              DOUBLE    Array[2354]</span>
<span class="comments">;   DISTCORR        INT              1</span>
<span class="comments">;   DCOUNTS         DOUBLE    Array[2354]</span>
<span class="comments">;   DR              DOUBLE    Array[2354]</span>
<span class="comments">;   DARKCORR        INT              1</span>
<span class="comments">;   BKGCOUNTS       DOUBLE    Array[2354]</span>
<span class="comments">;   BKG             DOUBLE    Array[2354]</span>
<span class="comments">;   INTTIME_S       FLOAT     Array[2354]</span>
<span class="comments">;   EDGE_TRIM       INT              2</span>
<span class="comments">;-</span>

<a id="get_telem:source"></a>function get_telem,times,time_in_sec=time_in_sec,debug=debug,$
	Edge_Trim=Edge_Trim,verbose=verbose,dark=dark,do_plot=do_plot,$
	sort_bywavelength=sort_bywavelength,sort_bygratpos=sort_bygratpos,$
	add_doppcorr=add_doppcorr,add_distcorr=add_distcorr,add_darkcorr=add_darkcorr
	if n_elements(add_darkcorr) ne 1 then add_darkcorr=0
	if n_elements(add_distcorr) ne 1 then add_distcorr=0
	if n_elements(add_doppcorr) ne 1 then add_doppcorr=0
	if n_elements(do_plot) ne 1 then do_plot=0
	if n_elements(dark) ne 1 then dark=0
	if n_elements(Edge_Trim) ne 1 then Edge_Trim=2
	if n_elements(sort_bywavelength) ne 1 then sort_bywavelength=0
	if n_elements(sort_bygratpos) ne 1 then sort_bygratpos=0
	if n_elements(verbose) ne 1 then verbose=0
	if n_elements(debug) ne 1 then debug=1
	if n_elements(time_in_sec) ne 1 then time_in_sec=0
	<span class="comments">;</span>
	RCS_ID="$Id: get_telem.pro,v 1.5 2018/04/24 16:46:22 penton Exp $"
	<span class="comments">;</span>
	<span class="comments">; Define Constants</span>
	<span class="comments">;</span>
	FF='(F10.3)'
	<span class="comments">; Define time constants</span>
	time0_ms=get_time0_ms()
	time0_s=time0_ms/1000.0
	start_time=times[0]
	end_time=times[1]
	<span class="comments">;</span>
	<span class="comments">; Read in the full telemetry stream</span>
	<span class="comments">;</span>
	telem=get_instrumentTelemetry()
	<span class="comments">;</span>
	if verbose or debug then help,telem,/str
	<span class="comments">;</span>
	<span class="comments">; sort by time, just to be sure</span>
	<span class="comments">;</span>
	index=sort(telem.time_s)
		stimes_s	=telem.time_s[index]
		stimes_ms	=telem.time_ms[index]
		sgratpos	=telem.gratpos[index]
		scounts		=telem.counts[index]
		stemps		=telem.temps[index]
	<span class="comments">;</span>
	<span class="comments">; trim to time window</span>
	<span class="comments">;</span>
	index=where((stimes_ms ge start_time) and (stimes_ms le end_time),ct)
		stimes_s	=stimes_s[index]
		stimes_ms	=stimes_ms[index]
		sgratpos	=sgratpos[index]
		scounts		=scounts[index]
		stemps		=stemps[index]
	<span class="comments">;</span>
	<span class="comments">; if the grating position is valid, get the wavelength and binsize</span>
	<span class="comments">;</span>
	med_dwave=(dw=-1)
	irr=(dirr=(dwaves=(gwaves=(delta_waves=replicate(!values.f_nan,ct)))))
	index=where((sgratpos gt 0.0),good_gratpos)
	if good_gratpos ge 1 then begin
		gtimes_ms=stimes_ms[index]
		gtimes_s=stimes_s[index]
		ggratpos=sgratpos[index]
		gcounts=scounts[index]
		gtemps=stemps[index]
		gratderiv=deriv(ggratpos)
		<span class="comments">;</span>
		<span class="comments">; lets keep it simple, just focus on the main scan</span>
		<span class="comments">; (trim the backlash, if that is what it is)</span>
		mgd=median(gratderiv)
		index=(mgd gt 0 ? where(gratderiv gt 0,ct) : where(gratderiv lt 0,ct))
		if ct ge 1 then begin
			gtimes_ms=gtimes_ms[index]
			gtimes_s=gtimes_s[index]
			ggratpos=ggratpos[index]
			gcounts=gcounts[index]
			gtemps=gtemps[index]
			gratderiv=gratderiv[index]
		endif
		if sort_bygratpos then begin
			<span class="comments">;</span>
			<span class="comments">; sort by sgratpos, if requested</span>
			<span class="comments">;</span>
			index=sort(ggratpos)
				gtimes_ms=gtimes_ms[index]
				gtimes_s=gtimes_s[index]
				ggratpos=ggratpos[index]
				gcounts=gcounts[index]
				gtemps=gtemps[index]
		endif

		gwaves=gp_to_wave(ggratpos)
		<span class="comments">;</span>
		<span class="comments">; Ok, one last sort by wavelength, if requested</span>
		<span class="comments">;</span>
		if sort_bywavelength then begin
			index=sort(gwaves)
				gwaves=gwaves[index]
				gtimes_ms=gtimes_ms[index]
				gtimes_s=gtimes_s[index]
				ggratpos=ggratpos[index]
				gcounts=gcounts[index]
				gtemps=gtemps[index]
		endif
		<span class="comments">;</span>
		<span class="comments">; Get the Dispersion, which seems to be changing</span>
		<span class="comments">;</span>
		<span class="comments">; use (abs(left)+abs(right))/2 to get binsize</span>
		<span class="comments">;</span>
		delta_waves=(abs(gwaves-shift(gwaves,-1))+abs(gwaves-shift(gwaves,1)))/2.0
		<span class="comments">;</span>
		<span class="comments">; fix the edges, this probably doesn't work on the Quickscan</span>
		<span class="comments">;</span>
		delta_waves[0:1]=delta_waves[2]
		delta_waves[-2:-1]=delta_waves[-3]
		<span class="comments">;</span>
		<span class="comments">; Trim the edges</span>
		<span class="comments">;</span>
		if Edge_Trim ge 1 then begin
			if verbose then message,/info,'Trimming Ends by '+string1i(Edge_Trim)
			gtimes_s =gtimes_s[Edge_Trim:(-Edge_Trim)]
			gtimes_ms=gtimes_ms[Edge_Trim:(-Edge_Trim)]
			ggratpos=ggratpos[Edge_Trim:(-Edge_Trim)]
			gcounts=gcounts[Edge_Trim:(-Edge_Trim)]
			gtemps=gtemps[Edge_Trim:(-Edge_Trim)]
			gwaves=gwaves[Edge_Trim:(-Edge_Trim)]
			delta_waves=delta_waves[Edge_Trim:(-Edge_Trim)]
		endif
		med_dwave=median(abs(delta_waves))
	endif else begin
		gtimes_ms=stimes_ms
		gtimes_s=stimes_s
		ggratpos=sgratpos
		gcounts=scounts
		gtemps=stemps
		med_dwave=!values.f_nan
	endelse
	<span class="comments">;</span>
	inttime_s=get_inttime(gtimes_ms,/in_sec)
	<span class="comments">;</span>
	<span class="comments">; Make sure that no bogus binsizes crept in</span>
	<span class="comments">;</span>
	index=where(delta_waves le 0.0,ct)
	if ct ge 1 then delta_waves[index]=!values.f_nan
	<span class="comments">;</span>
	if dark ne 1 then begin
		if verbose then message,/info,'Dwave = '+string1f(med_dwave,format=FF)+' nm'

		dwaves=doppcorr(gwaves,gtimes_ms,time_in_s=0,wave_in_m=0,dw=dw)
		waves=(add_doppcorr ? dwaves : gwaves)

		dcounts=distcorr(gcounts,gtimes_ms,time_in_s=0,dr=dr)
		counts=(add_distcorr ? dcounts : gcounts)

		bkgcounts=darkcorr(counts,inttime_s,gtemps,time_in_s=1,bkg=bkg)
		counts=(add_darkcorr ? bkgcounts : counts)
		<span class="comments">;</span>
		<span class="comments">; Add distance and doppler corrections, if requested</span>
		<span class="comments">;</span>
		irr=counts_to_irr(gtimes_ms,waves,counts,delta_waves,/time_in_ms,/wave_in_nm)

	endif else begin
		dr=-1
		bkgcounts=0
		bkg=0
		dcounts=gcounts
		counts=gcounts
		dwaves=gwaves
		waves=gwaves
		if verbose then message,/info,'Dark exposure, skipping counts_to_irr'
	endelse

	out={start_time:start_time,end_time:end_time,$
		times_ms:gtimes_ms,times_s:gtimes_s,$
		time_ms0:gtimes_ms[0],time_s0:gtimes_s[0],$
		temps:gtemps,$
		ggratpos:ggratpos,gwaves:gwaves,gcounts:gcounts,$
		irr:irr,$
		waves:waves,counts:counts,$
		delta_waves:delta_waves,binsize:med_dwave,$
		doppcorr:add_doppcorr,dwaves:dwaves,dw:dw,$
		distcorr:add_distcorr,dcounts:dcounts,dr:dr,$
		darkcorr:add_darkcorr,bkgcounts:bkgcounts,bkg:bkg,$
		inttime_s:inttime_s,$
		edge_trim:edge_trim}
	if debug then begin
		help,out,/str
	endif
	return,out
end
</code>
    </div>
  </body>
</html>